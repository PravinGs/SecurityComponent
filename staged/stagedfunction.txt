int LogService::zipAndEmptyFile(const string filePath) 
{
    std::string zipFilePath = filePath + ".zip";

    // Zip the file
    std::string zipCommand = "zip " + zipFilePath + " " + filePath;
    system(zipCommand.c_str());

    // Empty the original file
    std::ofstream file(filePath, std::ios::out | std::ios::trunc);
    file.close();
    agent_utils::write_log("File [ " + filePath + " ]" + "zipped to [ " + zipFilePath + " ]", SUCCESS);
    return SUCCESS;
}

std::chrono::system_clock::time_point Schedular::createAdjustedTimePoint(int hours, int minutes, int seconds)
{
    // Get the current time point
    std::chrono::system_clock::time_point now = std::chrono::system_clock::now();

    // Convert the current time point to a time_t value
    std::time_t now_time = std::chrono::system_clock::to_time_t(now);

    // Convert the time_t value to a tm structure
    std::tm* now_tm = std::localtime(&now_time);

    //Add the specified hours, minutes, and seconds to the tm structure
    now_tm->tm_hour = hours;
    now_tm->tm_min = minutes;
    now_tm->tm_sec = seconds;

    // Normalize the modified tm structure
    std::mktime(now_tm);

    // Convert the modified tm structure back to a time_t value
    std::time_t adjusted_time = std::mktime(now_tm);

    // Convert the adjusted time back to a time_point
    std::chrono::system_clock::time_point adjusted_time_point = std::chrono::system_clock::from_time_t(adjusted_time);

}
std::chrono::system_clock::time_point Schedular::convertToTimePoint(const std::string& timeStr)
{
    std::istringstream iss(timeStr);
    char token;
    int hours, minutes, seconds;
    iss >> hours >> token >>  minutes >> token >> seconds;

    return createAdjustedTimePoint(hours, minutes,seconds);
}    
List Schedular::setEventsNew()    
{
    List list;
    string token;
    vector<string> times;
    if (this->table.size() == 0)
    {
        return list;
    }
    string time = table["schedular"]["monitor"];
    cout << time << endl;
    std::stringstream stream(time);
    
    while (std::getline(stream, token, ','))
    {
        times.push_back(token);
    }

    for (int i = 0; i < (int)times.size(); i++)
    {
        list.add(times[i]);
    }

    return list;
}

std::map<string, string> getLogAttributes(const string path);
std::map<string, string> LogService::getLogAttributes(const string path)
{
    std::map<string, string> table;
    fstream file(path, std::ios::in);
    string line;
    while (std::getline(file, line))
    {
        std::stringstream stream(line);
        string token;
        string name;
        string value;
        int index = 0;
        while (std::getline(stream, token, '='))
        {
            if (index == 0)
            {
                name = token;
            }
            else
            {
                value = token;
            }
            index++;
        }
        table[name] = value;
    }

    return table;
}

string _createJSON(const string line, vector<string> names, char delimeter);
string LogService::_createJSON(const string line, vector<string> names, char delimeter)
{
    vector<string> tokens;
    string token;
    string serializedJson = "";
    Json::Value json;
    Json::StreamWriterBuilder writer;
    std::stringstream iss(line);
    while (std::getline(iss, token, delimeter))
    {
        tokens.push_back(token);
    }
    for (int i = 0; i < (int)names.size(); i++)
    {
        json[names[i]] = tokens[i];
    }
    serializedJson = Json::writeString(writer, json);
    return serializedJson;
}


int LogService::addToZip(const std::string zipPath, const std::string filePath)
{
    cout << "addToZip : " << filePath <<endl;
    gzFile zipFile = gzopen(zipPath.c_str(), "ab");
    if (!zipFile)
    {
        agent_utils::write_log("Error opening zip file.", FAILED);
        return FAILED;
    }

    fstream inputFile(filePath, std::ios::binary);
    if (!inputFile)
    {
        agent_utils::write_log("Error opening input file.", FAILED);
        gzclose(zipFile);
        return FAILED;
    }
    string buffer;
    while (std::getline(inputFile, buffer))
    {
        gzwrite(zipFile, buffer.c_str(), static_cast<unsigned int>(inputFile.gcount()));
    }

    inputFile.close();
    gzclose(zipFile);

    std::ofstream file(filePath, std::ios::out | std::ios::trunc);
    file.close();
    agent_utils::write_log("File [ " + filePath + " ]" + "zipped to [ " + zipPath + " ]", SUCCESS);
    return SUCCESS;
}

int LogService::isZipExist(string zipPath)
{
    gzFile zipFile = gzopen(zipPath.c_str(), "ab");
    if (!zipFile)
    {
        agent_utils::write_log("Zip File not Exist it will create new zip file name: " + zipPath);
    }
    
    gzFile newZipFile = gzopen(zipPath.c_str(), "wb");
    if (!newZipFile)
    {
        agent_utils::write_log("Cannot create Zip File: " + zipPath, FAILED);
        return FAILED;
    }
    agent_utils::write_log("Zip File created: " + zipPath, SUCCESS);
    gzclose(newZipFile);
    return SUCCESS;
}

int LogService::checkFileSize(const string filePath)
{
    string zipPath = filePath + "_" + agent_utils::get_current_time().substr(0, 10) + "-"+ agent_utils::get_current_time().substr(10)+".zip";
    std::ifstream file(filePath, std::ios::binary | std::ios::ate);
    if (!file)
    {
        std::cerr << "Failed to open file: " << filePath << std::endl;
        return FAILED;
    }

    std::streamsize fileSize = file.tellg();

    cout << "Filesize : " << (int)fileSize << endl;
    file.close();

    if (fileSize < (long int)SIZE_LIMIT)
    {
        return SUCCESS;
    }
    agent_utils::write_log("File [ " + filePath + " ]" + " exceeds the size limit. Zipping and emptying the file...");
    if (isZipExist(zipPath) == FAILED)
        return FAILED;
    cout << "Zip Exist" << endl;
    return addToZip(zipPath, filePath);
}

int LogService::processFiles(string directoryPath)
{
    int result = SUCCESS;
    struct stat fileStat;
    DIR *dir = opendir(directoryPath.c_str());
    dirent *entry = NULL;
    if (dir == NULL)
    {
        agent_utils::write_log("Invalid directory [ " + directoryPath + " ]", FAILED);
        return FAILED;
    } 

    while ((entry = readdir(dir)) != NULL)
    {
        string filePath = directoryPath + entry->d_name;
        if (stat(filePath.c_str(), &fileStat) == 0) {
            if (S_ISREG(fileStat.st_mode)) {
                std::cout << entry->d_name << std::endl;
                result = checkFileSize(filePath);
               
            } else std::cout << "Skipping non-regular file: " << entry->d_name << std::endl;
                
        } else 
        {
            std::cout << "Error accessing file: " << entry->d_name << std::endl;
        }
    }
    return result;
}

int LogService::getSysLog(Json::Value &json, vector<string> names, const string path, const string writePath, const char delimeter)
{
    json["Priority"] = 0; // For system log there is no room to add priority.
    const string sep = "|";
    vector<string> logs;
    string line;

    fstream file(path, std::ios::in);
    if (!file)
    {
        agent_utils::write_log("Failed to read " + path + " check file path and file permission", FAILED);
        return FAILED;
    }

    while (std::getline(file, line))
    {
        string log;
        string token;
        std::stringstream stream(line);
        int index = 0;
        bool isCriticalLog = false;
        while (std::getline(stream, token, delimeter) && index < 4)
        {
            if (index == 0) /*To collect Date and Time from the Record*/
            {
                string timestamp = token;
                string formattedTime;
                while (index < 2 && std::getline(stream, token, delimeter))
                {
                    timestamp += " " + token;
                    index++;
                }
                if (agent_utils::convert_time_format(timestamp, formattedTime) == SUCCESS)
                {
                    log += formattedTime;
                    index = 1;
                }
                continue;
            }

            if (index == 3) /* To collect Message from the */
            {
                string message = token;
                while (std::getline(stream, token, delimeter))
                {
                    message += ' ' + token;
                }
                isCriticalLog = isPriorityLog(message);
                log += sep + message;
                index = 4;
                continue;
            }
            log += sep + token;
            index++;
        }
        if (isCriticalLog)
        {
            logs.push_back(log + sep + "Error");
        }
    }

    agent_utils::write_log("Syslog collected", SUCCESS);
    if (splitLineto_vector(logs[0], sep[0]).size() < names.size())
    {
        agent_utils::write_log("Invalid Log Attributes configured for syslog", FAILED);
        return FAILED;
    }
    return saveLog(json, writePath, logs, names, sep[0]);
}

int LogService::getAppLog(Json::Value &json, vector<string> names, const string path, const string writePath, const char delimeter)
{
    fstream file(path);
    vector<string> logs;
    string line;
    if (!file)
    {
        agent_utils::write_log("Reading App Log Invalid configuration Path [ " + path + " ]", FAILED);
        return FAILED;
    }

    while (std::getline(file, line))
    {
        if (line.length() == 0)
            continue;

        if (isPriorityLog(line))
            logs.push_back(line);
    }
    file.close();
    agent_utils::write_log("Applog collected from " + path, SUCCESS);
    if (splitLineto_vector(logs[0], delimeter).size() < names.size())
    {
        agent_utils::write_log("Invalid Log Attributes configured for Applog", FAILED);
        return FAILED;
    }
    return saveLog(json, writePath, logs, names, delimeter);
}
   
bool isPriorityLog(const std::string &line)
{
    string lowerLine = line;
    string lowerSearchTerm = "error";
    std::transform(lowerLine.begin(), lowerLine.end(), lowerLine.begin(), [](unsigned char c)
                   { return std::tolower(c); });
    std::transform(lowerSearchTerm.begin(), lowerSearchTerm.end(), lowerSearchTerm.begin(), [](unsigned char c)
                   { return std::tolower(c); });

    return lowerLine.find(lowerSearchTerm) != std::string::npos;
}

    // logLevel["none"] = 0;
    // logLevel["trace"] = 1;
    // logLevel["debug"] = 2;
    // logLevel["warning"] = 3;
    // logLevel["error"] = 4;
    // logLevel["critical"] = 5;
    Monitor::SYS_PROPERTIES monitor_service::get_system_properties()
{
    agent_utils::write_log("Request for collecting System Properties");
    struct Monitor::SYS_PROPERTIES properties;
    struct sysinfo info;
    struct statvfs stat;
    sysinfo(&info);
    statvfs("/", &stat);
    properties.ram = (double)info.totalram * info.mem_unit;
    properties.disk = stat.f_blocks * stat.f_frsize;
    properties.cpu = (double)sysconf(_SC_NPROCESSORS_ONLN);
    agent_utils::write_log("System Properties collected");
    return properties;
}

#include <iostream>
#include <curl/curl.h>
#include <string>

// Callback function to write the response data into a string
size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* response) {
    size_t totalSize = size * nmemb;
    response->append(static_cast<char*>(contents), totalSize);
    return totalSize;
}

int main() {
    CURL* curl;
    CURLcode res;
    std::string response;

    // Initialize curl
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();

    if (curl) {
        // Set the URL
        curl_easy_setopt(curl, CURLOPT_URL, "http://13.232.193.41/Log/GetLogs?OrgId=234225");

        // Set the accept header
        struct curl_slist* headers = nullptr;
        headers = curl_slist_append(headers, "accept: */*");
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

        // Set the write callback function
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

        // Perform the request
        res = curl_easy_perform(curl);

        // Check for errors
        if (res != CURLE_OK) {
            std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << std::endl;
        }
        else  {
            // Print the response
            std::cout << "Response:\n" << response << std::endl;
        }

        // Clean up
        curl_easy_cleanup(curl);
        curl_global_cleanup();
    }

    return 0;
}

        // Queue queue(config_table["rabbitmq"]["ca_pem"], config_table["rabbitmq"]["client_pem"], config_table["rabbitmq"]["client_key"]);
        // if (queue.send(writePath, config_table[sysLogName]["queue"]) == SUCCESS)
        // {
        //     cout << "Queue Published successfully" << endl;
        //     _config_service.clean_file(writePath);
        //     return SUCCESS;
        // }

// void Schedule::run(string processName, string timePattern)
// {
//     vector<int> patternTable;
//     if (processTimePattern(patternTable, timePattern) == FAILED)
//         return;
//     int elapsedTime = patternTable[0] + (patternTable[1] * 60) + (patternTable[2] * 3600);
//     do
//     {
//         std::chrono::system_clock::time_point currentTime = std::chrono::system_clock::now();
//         std::chrono::system_clock::time_point executionTime = currentTime + std::chrono::seconds(elapsedTime);
//         printTime(executionTime);
//         std::chrono::system_clock::duration duration = executionTime - currentTime;
//         int waitingTime = std::chrono::duration_cast<std::chrono::seconds>(duration).count();
//         cout << processName << " waiting for execution...." << endl;
//         std::this_thread::sleep_for(std::chrono::seconds(waitingTime));
//         if (processName == "monitor")
//         {
//             if (_monitor_controller.getMonitorLog(_config_table) == SUCCESS)
//             {
//                 cout << "Monitor Log collected successfully." << endl;
//             }
//             else
//             {
//                 agent_utils::write_log("Reading Process details operation stopped");
//             }
//         }
//         else if (processName == "applog")
//         {
//             if (_logController.appLogManager(_config_table) == SUCCESS)
//             {
//                 cout << "Applog operation done" << endl;
//             }
//             else
//             {
//                 agent_utils::write_log("Reading AppLog process stopped");
//             }
//         }
//         else if (processName == "syslog")
//         {
//             if (_logController.getSysLog(_config_table) == SUCCESS)
//             {
//                 cout << "Syslog operation done" << endl;
//             }
//             else
//             {
//                 agent_utils::write_log("Reading SysLog process stopped");
//             }
//         }
//         else if (processName == "firmware")
//         {
//             if (_fController.start(_config_table) == SUCCESS)
//             {
//                 cout << "FirmWare operation done" << endl;
//             }
//             else
//             { /*Do somthing*/
//             }
//         }
//         cout << processName << " execution done." << endl;

//     } while (elapsedTime > 0);
// }

// void Schedule::start()
// {
//     if (!_isReadyToSchedule)
//         return;
//     vector<string> processes;
//     map<string, string> schedular = _config_table["schedular"];
//     for (const auto &process : schedular)
//     {
//         processes.push_back(process.first);
//     }
//     std::vector<std::thread> threads(processes.size());

//     for (int i = 0; i < (int)processes.size(); i++)
//     {
//         try
//         {
//             string processName = processes[i];
//             string processTimePattern = schedular[processes[i]];
//             cout << processName << " : " << processTimePattern << endl;
//             threads[i] = std::thread([&, processName, processTimePattern]()
//                                      { run(processName, processTimePattern); });
//         }
//         catch (const std::exception &e)
//         {
//             std::cerr << e.what() << '\n';
//         }
//     }

//     for (auto &thread : threads)
//     {
//         if (thread.joinable())
//             thread.join();
//     }

//     cout << "done" << endl;
// }


class ThreadPool
{
private:
    std::vector<std::thread> threads;
    std::queue<std::function<void()>> tasks;
    std::mutex queueMutex;
    std::condition_variable condition;
    bool stop;
    void threadWorker()
    {
        while (true)
        {
            std::function<void()> task;

            {
                std::unique_lock<std::mutex> lock(queueMutex);

                condition.wait(lock, [this]()
                               { return stop || !tasks.empty(); });

                if (stop && tasks.empty())
                {
                    return;
                }

                task = std::move(tasks.front());
                tasks.pop();
            }

            task();
        }
    }

public:
    ThreadPool(int numThreads) : stop(false)
    {
        for (int i = 0; i < numThreads; ++i)
        {
            threads.emplace_back(std::bind(&ThreadPool::threadWorker, this));
        }
    }

    ~ThreadPool()
    {
        {
            std::unique_lock<std::mutex> lock(queueMutex);
            stop = true;
        }

        condition.notify_all();

        for (auto &thread : threads) {
            if (thread.joinable())
                thread.join();
        }
    }

    template <class Function, class... Args>
    void enqueue(Function &&function, Args &&...args)
    {
        {
            std::unique_lock<std::mutex> lock(queueMutex);
            tasks.emplace(std::bind(std::forward<Function>(function), std::forward<Args>(args)...));
        }

        condition.notify_one();
    }
};

// int log_service::save_read_logs(const vector<string> &logs, const string &app_name)
// {
//     string file_path;
//     auto today = std::chrono::system_clock::now();
//     auto time_info = std::chrono::system_clock::to_time_t(today);
//     std::tm *tm_info = std::localtime(&time_info);

//     int day = tm_info->tm_mday;
//     int month = tm_info->tm_mon + 1;
//     int year = tm_info->tm_year + 1900;

//     if (os::handle_local_log_file(day, month, year, file_path, app_name) == FAILED)
//     {
//         return FAILED;
//     }

//     fstream file(file_path, std::ios::app);

//     for (string line : logs)
//     {
//         file << line << "\n";
//     }

//     file.close();

//     return SUCCESS;
// }

// int log_service::get_json_write_path(string &timestamp)
// {
//     string file_path = BASE_LOG_DIR;

//     if (os::is_dir_exist(file_path) == FAILED)
//     {
//         os::create_dir(file_path);
//     }

//     file_path += "json";

//     if (os::is_dir_exist(file_path) == FAILED)
//     {
//         os::create_dir(file_path);
//     }

//     file_path += "/" + timestamp + ".json";

//     std::ofstream file(file_path);
//     if (!file)
//     {
//         agent_utils::write_log(FILE_ERROR + file_path, FAILED);
//         return FAILED;
//     }
//     file.close();
//     timestamp = file_path;
//     return SUCCESS;
// }

// int log_service::save_json(Json::Value &json, const string &path, const vector<string> &logs, const vector<string> &columns, const char &delimeter)
// {
//     string json_write_path = path;
//     if (get_json_write_path(json_write_path) == FAILED)
//         return FAILED;

//     fstream file(json_write_path, std::ios::out);
//     Json::StreamWriterBuilder writer_builder;
//     if (!file)
//     {
//         agent_utils::write_log(FWRITE_FAILED + json_write_path, FAILED);
//         return FAILED;
//     }

//     json["LogObjects"] = Json::Value(Json::arrayValue);
//     for (auto log : logs)
//     {
//         Json::Value jsonLog;

//         standard_log_attrs fLog = standard_log_attrs(log);
//         jsonLog["TimeGenerated"] = fLog.timestamp;
//         jsonLog["UserLoginId"] = fLog.user;
//         jsonLog["ServiceName"] = fLog.program;
//         jsonLog["Message"] = fLog.message;
//         jsonLog["LogLevel"] = fLog.level;
//         jsonLog["LogCategory"] = fLog.category;

//         json["LogObjects"].append(jsonLog);
//     }
//     std::unique_ptr<Json::StreamWriter> writer(writer_builder.newStreamWriter());
//     writer->write(json, &file);
//     file.close();
//     agent_utils::write_log(FWRITE_SUCCESS + json_write_path, SUCCESS);
//     return SUCCESS;
// }

int log_service::get_syslog(const string &app_name, Json::Value &json, const vector<string> &log_attributes, const string &path, string &last_read_time, const vector<string> &log_levels, const char &remote)
{
    bool flag = true;
    int result = SUCCESS;
    // const char delimeter = ' ';
    vector<string> logs;

    string log_dir = BASE_LOG_DIR;
    log_dir += BASE_LOG_ARCHIVE;
    string next_reading_time = last_read_time;

    if (strcmp(app_name.c_str(), "syslog") == 0 || strcmp(app_name.c_str(), "auth") == 0)
    {

        if (remote == 'y' || remote == 'Y')
        {
            UdpQueue queue;
            result = read_remote_syslog(queue, logs);
            queue.stop();
        }
        else
        {
            // result = read_syslog_file(path, logs, delimeter, last_read_time, flag, log_levels, next_reading_time);
            result = SUCCESS;
        }
        if (logs.size() == 0 || result == FAILED)
        {
            agent_utils::write_log("Read 0 logs for" + app_name, WARNING);
        }
        else
        {
            last_read_time = next_reading_time;
            agent_utils::write_log(app_name + " logs collected", INFO);
            if (config.to_vector(logs[0], '|').size() < log_attributes.size())
            {
                agent_utils::write_log("Invalid Log Attributes configured for " + app_name, FAILED);
                result = FAILED;
            }
            else
            {
                string fileName = next_reading_time + "-" + app_name;
                result = save_json(json, fileName, logs, log_attributes, '|');
            }

            if ((result = save_read_logs(logs, app_name)) == SUCCESS)
            {
                agent_utils::write_log("Storing " + app_name + " logs started", INFO);
                agent_utils::write_log(FWRITE_SUCCESS + log_dir, INFO);
            }
            else
            {
                agent_utils::write_log(FWRITE_FAILED + log_dir, FAILED);
            }
        }
    }
    else if (strcmp(app_name.c_str(), "dpkg") == 0)
    {
        result = read_dpkg_logfile(path, logs, last_read_time, next_reading_time, flag);
        last_read_time = next_reading_time;
        if (logs.size() == 0)
        {
            agent_utils::write_log("Read 0 logs for " + app_name);
        }
        else
        {
            agent_utils::write_log("Storing " + app_name + " logs started", INFO);
            if ((result = save_read_logs(logs, app_name)) == SUCCESS)
            {
                agent_utils::write_log(FWRITE_SUCCESS + log_dir, INFO);
            }
            else
            {
                agent_utils::write_log(FWRITE_FAILED + log_dir, FAILED);
            }
        }
    }

    return result;
}

    int isValidLogConfig(map<string, map<string, string>> &config_table, Json::Value &json, const string& name, char &remote, const string& prevTime)
    {
        int result = SUCCESS;
        try
        {
            string hostName = "unknown";

            vector<string> names = _config_service.to_vector(config_table[name]["columns"], ',');

            if (name != "syslog" && os::is_dir_exist(config_table[name]["log_directory"]))
            {
                throw std::invalid_argument("Invalid log directory for " + name);
            };

            if (names.size() == 0)
            {
                throw std::invalid_argument("Log attributes not configured for " + name);
            }

            if (config_table[name]["remote"].length() == 1)
            {
                remote = (config_table[name]["remote"][0] == '1') ? 'y' : 'n';
            }

            // else if (config_table[name]["remote"].length() > 1) { throw std::invalid_argument("Delimeter not configured Properly"); }

            if (prevTime.length() == 0)
            {
                throw std::invalid_argument("No Specific time mentioned to collect log");
            }

            if (agent_utils::get_hostname(hostName) == FAILED)
                return FAILED;

            json["OrgId"] = 234225;
            json["AppName"] = config_table[name]["name"];
            json["Source"] = hostName;
        }
        catch (exception &e)
        {
            result = FAILED;
            string error = e.what();
            agent_utils::write_log(error, FAILED);
        }
        return result;
    }

    int patch_service::sftp_download(const patch_entity &entity)
{
    int returnVal = SUCCESS;
    string credential = username + ":" + password;
    int retry = d_properties.retry;
    FILE *file = NULL;
    CURLcode res;
    file = fopen(entity.download_path.c_str(), "ab");

    if (file == NULL)
    {
        agent_utils::write_log("Failed to open " + entity.download_path + " check file path and it's permission", FAILED);
        return FAILED;
    }

    entity.size = seek_file_size(file);

    if (curl == NULL)
    {
        agent_utils::write_log("Failed to initialize curl ", FAILED);
        return FAILED;
    }

    curl_easy_setopt(curl, CURLOPT_URL, d_properties.url.c_str());
    curl_easy_setopt(curl, CURLOPT_RESUME_FROM_LARGE, d_properties.size);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, NULL);
    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);

    curl_easy_setopt(curl, CURLOPT_SSH_AUTH_TYPES, CURLSSH_AUTH_PASSWORD);
    curl_easy_setopt(curl, CURLOPT_USERPWD, credential.c_str());

    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);

    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, d_properties.minSpeed);
    curl_easy_setopt(curl, CURLOPT_MAX_RECV_SPEED_LARGE, d_properties.maxSpeed);
    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, d_properties.timeout);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, d_properties.timeout);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);
    do
    {
        res = curl_easy_perform(curl);

        if (res != CURLE_OK)
        {
            string error = curl_easy_strerror(res);
            agent_utils::write_log(error, FAILED);
            std::cerr << "Error: " << error << "\n";
            if (res == CURLE_COULDNT_RESOLVE_HOST)
            {
                returnVal = FAILED;
                break;
            }
            retry--;
            if (retry > 0)
            {
                std::cerr << "Retrying download in 10 seconds..."
                          << "\n";
                agent_utils::write_log("Retrying download in 10 seconds...");
                std::this_thread::sleep_for(std::chrono::seconds(5));
            }
            else
            {
                returnVal = SERVER_ERROR;
            }
        }
        else
        {
            retry = d_properties.retry;
        }
    } while (res != CURLE_OK && retry > 0);
    if (d_properties.retry <= 0)
    {
        returnVal = FAILED;
    }
    fclose(file);
    return returnVal;
}

int patch_service::create_download_property(map<string, map<string, string>> &table)
{
    int result = SUCCESS;
    this->d_properties.writePath = table["firmware"]["write_path"];
    if (d_properties.writePath.empty())
    {
        agent_utils::write_log("Write path not defined", WARNING);
        result = FAILED;
    }
    this->d_properties.writePath = table["firmware"]["root_dir"];
    if (d_properties.writePath.empty())
    {
        agent_utils::write_log("Root directory not defined", WARNING);
        result = FAILED;
    }
    d_properties.url = table["firmware"]["url"];
    if (d_properties.url.empty())
    {
        agent_utils::write_log("url path not defined", WARNING);
        result = FAILED;
    }
    d_properties.fileName = extract_ile_name(d_properties.url);
    if (d_properties.fileName.empty())
    {
        agent_utils::write_log("fileName path not defined", WARNING);
        result = FAILED;
    }
    d_properties.downloadPath = d_properties.writePath + d_properties.fileName;
    if (d_properties.downloadPath.empty())
    {
        agent_utils::write_log("downloadPath path not defined", WARNING);
        result = FAILED;
    }
    username = table["firmware"]["username"];
    password = table["firmware"]["password"];
    try
    {
        d_properties.maxSpeed = std::stoi(table["firmware"]["max_download_speed"]);
        d_properties.minSpeed = std::stoi(table["firmware"]["min_download_speed"]);
        d_properties.timeout = std::stoi(table["firmware"]["time_out"]);
    }
    catch (const std::exception &e)
    {
        std::cerr << e.what() << '\n';
        result = FAILED;
    }
    return result;
}

    void home(SSL *ssl)
    {
        server_data s_data;
        s_data.status = 1;
        std::strncpy(s_data.data, "ok", 2);
        s_data.data[sizeof(s_data.data) - 1] = '\0';
        string server_data_buffer(reinterpret_cast<const char *>(&s_data), sizeof(s_data));
        char received_buffer[sizeof(client_data)];

        int bytes_received = SSL_read(ssl, received_buffer, sizeof(received_buffer));

        if (bytes_received < 0)
        {
            std::cerr << "Error receiving data: " << ERR_error_string(ERR_get_error(), nullptr) << std::endl;
            return;
        }
        else
        {
            client_data c_data = *reinterpret_cast<client_data *>(received_buffer);
            cout << c_data.client_id << '\n';
            cout << c_data.data << '\n';
            cout << c_data.is_alive << '\n';
        }

        int bytes_sent = SSL_write(ssl, server_data_buffer.c_str(), server_data_buffer.size());

        if (bytes_sent < 0)
        {
            std::cerr << "Error sending data: " << ERR_error_string(ERR_get_error(), nullptr) << std::endl;
            return;
        }

        return;
    }